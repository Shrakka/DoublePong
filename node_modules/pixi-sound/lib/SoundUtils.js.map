{"version":3,"file":"SoundUtils.js","sourceRoot":"","sources":["../src/SoundUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import uuid = require(\"uuid/v4\");\nimport soundLibrary from \"./index\";\nimport Sound from \"./Sound\";\n\nexport interface RenderOptions {\n    width?: number;\n    height?: number;\n    fill?: string|CanvasPattern|CanvasGradient;\n}\n\n/**\n * Utilities that work with sounds.\n * @namespace PIXI.sound.utils\n */\nexport default class SoundUtils\n{\n    /**\n     * Create a new sound for a sine wave-based tone.\n     * @method PIXI.sound.utils.sineTone\n     * @param {PIXI.sound.SoundContext} soundContext\n     * @param {Number} [hertz=200] Frequency of sound.\n     * @param {Number} [seconds=1] Duration of sound in seconds.\n     * @return {PIXI.sound.Sound} New sound.\n     */\n    public static sineTone(hertz: number = 200, seconds: number = 1): Sound\n    {\n        const soundContext = soundLibrary.context;\n        const soundInstance = new Sound(soundContext, {\n            singleInstance: true,\n        });\n\n        // set default value\n        const nChannels = 1;\n        const sampleRate = 48000;\n        const amplitude = 2;\n\n        // create the buffer\n        const buffer = soundContext.audioContext.createBuffer(\n            nChannels,\n            seconds * sampleRate,\n            sampleRate,\n        );\n        const fArray = buffer.getChannelData(0);\n\n        // fill the buffer\n        for (let i = 0; i < fArray.length; i++)\n        {\n            const time  = i / buffer.sampleRate;\n            const angle = hertz * time * Math.PI;\n            fArray[i] = Math.sin(angle) * amplitude;\n        }\n\n        // set the buffer\n        soundInstance.buffer = buffer;\n        soundInstance.isLoaded = true;\n        return soundInstance;\n    }\n\n    /**\n     * Render image as Texture\n     * @method PIXI.sound.utils.render\n     * @param {PIXI.sound.Sound} sound Instance of sound to render\n     * @param {Object} [options] Custom rendering options\n     * @param {Number} [options.width=512] Width of the render\n     * @param {Number} [options.height=128] Height of the render\n     * @param {string|CanvasPattern|CanvasGradient} [options.fill='black'] Fill style for waveform\n     * @return {PIXI.Texture} Result texture\n     */\n    public static render(sound: Sound, options?: RenderOptions): PIXI.BaseTexture\n    {\n        options = Object.assign({\n            width: 512,\n            height: 128,\n            fill: \"black\",\n        }, options || {});\n\n        console.assert(!!sound.buffer, \"No buffer found, load first\");\n\n        const canvas: HTMLCanvasElement = document.createElement(\"canvas\");\n        canvas.width = options.width;\n        canvas.height = options.height;\n\n        const context: CanvasRenderingContext2D = canvas.getContext(\"2d\");\n        context.fillStyle = options.fill;\n        const data: Float32Array = sound.buffer.getChannelData(0);\n        const step: number = Math.ceil(data.length / options.width);\n        const amp: number = options.height / 2;\n\n        for (let i: number = 0; i < options.width; i++)\n        {\n            let min: number = 1.0;\n            let max: number = -1.0;\n\n            for (let j: number = 0; j < step; j++)\n            {\n                const datum: number = data[(i * step) + j];\n\n                if (datum < min)\n                {\n                    min = datum;\n                }\n                if (datum > max)\n                {\n                    max = datum;\n                }\n            }\n            context.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));\n        }\n        return PIXI.BaseTexture.fromCanvas(canvas);\n    }\n\n    /**\n     * Create a new \"Audio\" stream based on given audio path and project uri; returns the audio object.\n     * @method PIXI.sound.utils.playOnce\n     * @static\n     * @param {String} fileName Full path of the file to play.\n     * @param {Function} callback Callback when complete.\n     * @return {string} New audio element alias.\n     */\n    public static playOnce(src: string, callback?: (err?: Error) => void): string\n    {\n        const alias = uuid();\n\n        soundLibrary.add(alias, {\n            src,\n            preload: true,\n            autoPlay: true,\n            loaded: (err: Error) => {\n                if (err)\n                {\n                    console.error(err);\n                    soundLibrary.remove(alias);\n                    if (callback)\n                    {\n                        callback(err);\n                    }\n                }\n            },\n            complete: () => {\n                soundLibrary.remove(alias);\n                if (callback)\n                {\n                    callback(null);\n                }\n            },\n        });\n        return alias;\n    }\n}\n"]}